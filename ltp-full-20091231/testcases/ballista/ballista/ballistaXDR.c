/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */
/* ballistaXDR.c : Ballista RPC specification
 * Copyright (C) 1998-2001  Carnegie Mellon University
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License  
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
 
#include <rpc/types.h>
#include <rpc/xdr.h>

#include "ballistaRPC.h"

bool_t
xdr_b_param(XDR *xdrs, b_param objp)
{

	 register long *buf;

	 if (!xdr_vector(xdrs, (char *)objp, 255, sizeof(char), (xdrproc_t)xdr_char)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_my_line(XDR *xdrs, my_line *objp)
{

	 register long *buf;

	 if (!xdr_string(xdrs, objp, ~0)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_my_vector_lines(XDR *xdrs, my_vector_lines *objp)
{

	 register long *buf;

	 if (!xdr_array(xdrs, (char **)&objp->my_vector_lines_val, (u_int *)&objp->my_vector_lines_len, ~0, sizeof(my_line), (xdrproc_t)xdr_my_line)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_my_arr_vec_line(XDR *xdrs, my_arr_vec_line *objp)
{

	 register long *buf;

	 if (!xdr_array(xdrs, (char **)&objp->my_arr_vec_line_val, (u_int *)&objp->my_arr_vec_line_len, ~0, sizeof(my_vector_lines), (xdrproc_t)xdr_my_vector_lines)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_one_dim(XDR *xdrs, one_dim *objp)
{

	 register long *buf;

	 if (!xdr_array(xdrs, (char **)&objp->one_dim_val, (u_int *)&objp->one_dim_len, ~0, sizeof(b_param), (xdrproc_t)xdr_b_param)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_two_dim(XDR *xdrs, two_dim *objp)
{

	 register long *buf;

	 if (!xdr_array(xdrs, (char **)&objp->two_dim_val, (u_int *)&objp->two_dim_len, ~0, sizeof(one_dim), (xdrproc_t)xdr_one_dim)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_three_dim(XDR *xdrs, three_dim *objp)
{

	 register long *buf;

	 if (!xdr_array(xdrs, (char **)&objp->three_dim_val, (u_int *)&objp->three_dim_len, ~0, sizeof(two_dim), (xdrproc_t)xdr_two_dim)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_info(XDR *xdrs, info *objp)
{

	 register long *buf;
	 if (!xdr_my_arr_vec_line(xdrs, &objp->mvl)) {
		 return (FALSE);
	 }
	 if (!xdr_int(xdrs, &objp->NumArg)) {
		 return (FALSE);
	 }
	 if (!xdr_double(xdrs, &(objp->sample_size))) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_return_info(XDR *xdrs, return_info *objp)
{

	 register long *buf;

	 if (!xdr_three_dim(xdrs, &objp->my_three_dim)) {
		 return (FALSE);
	 }
	 if (!xdr_int(xdrs, &objp->total)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_data_from_client(XDR *xdrs, data_from_client *objp)
{

	 register long *buf;

	 if (!xdr_string(xdrs, &objp->passtatus, ~0)) {
		 return (FALSE);
	 }
	 if (!xdr_int(xdrs, &objp->call_ret)) {
		 return (FALSE);
	 }
	 if (!xdr_string(xdrs, &objp->sys_err, ~0)) {
		 return (FALSE);
	 }
	 if (!xdr_two_dim(xdrs, &objp->params)) {
		 return (FALSE);
	 }
	 if (!xdr_int(xdrs, &objp->NumArg)) {
		 return (FALSE);
	 }
	 if (!xdr_string(xdrs, &objp->function, ~0)) {
		 return (FALSE);
	 }
	 return (TRUE);
}
